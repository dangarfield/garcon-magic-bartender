<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Garcon - Magic Bartender - Visualiser</title>
    <script src="/libs/dat.gui.min.js"></script>
    <script src="/libs/stats.min.js"></script>
    <script src="/libs/three.min.js"></script>
    <script src="/js/threejs/sea3d/SEA3D.js"></script>
    <script src="/js/threejs/sea3d/SEA3DLZMA.js"></script>
    <script src="/js/threejs/sea3d/SEA3DLoader.js"></script>
    <script src="/js/threejs/controls/OrbitControls.js"></script>
    <script src="/js/ThreeSteer.js"></script>
    <script src="/js/entity-positions.js"></script>
    <script src="/js/entity-profiles.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/main.css" />
    <link rel="stylesheet" type="text/css" href="/css/gui.css" />
</head>
<script>
    var container;
    var camera;

    var scene, renderer;
    var clock;
    var controls;
    var stats;

    var boundaries;
    var entities;
    var furniture;
    var params;
    var mesh;

    var path;
    var arrows, flags;

    var characters = [{
            index: 0,
            name: "white",
            url: "/models/avatar_white.tjs.sea"
        },
        {
            index: 1,
            name: "red",
            url: "/models/avatar_red.tjs.sea"
        },
        {
            index: 2,
            name: "black",
            url: "/models/avatar_black.tjs.sea"
        }
    ];

    var animations = [{
            index: 0,
            name: "idle",
            url: "/models/animations/idle.tjs.sea"
        },
        {
            index: 1,
            name: "walk",
            url: "/models/animations/walk.tjs.sea"
        },
        {
            index: 2,
            name: "jog",
            url: "/models/animations/jog.tjs.sea"
        },
        {
            index: 3,
            name: "run",
            url: "/models/animations/run.tjs.sea"
        }
    ];

    params = {
        maxSpeed: 5,
        maxForce: 3,
        numEntities: 72,
        thresholdRadius: 50,
        loop: false,
        avoid: false,
        avoidDistance: 10,
        size: {
            x: 2250,
            z: 1500
        },
        toBar: false,
        fromBar: false,
        toToilet: false,
        fromToilet: false,
        toSmoke: false,
        fromSmoke: false
    }



    var clickHistory = []

    var barQueue = []

    function processBarQueue() {
        console.log('Processing bar queue', barQueue)
        if (barQueue.length > 0) {
            var order = barQueue[0]
            if (order.status == 'waiting') {
                order.status = 'serving'
            } else if (order.status == 'serving') {
                order.status = 'DONE'
                var entity = entities[order.id]
                console.log('Served entity: ID:', order.id, 'Name:', order.name, 'Entity:', entity.name)
                barQueue.shift()
                entity.pathIndex = 0
                entity.action.type = 'fromBar'
                entity.action.path = getPath(entity, entity.action.type)
                console.log('Entity:', entity.name, 'Return:', entity.action.type)
                if (barQueue.length > 0) {
                    barQueue[0].status = 'serving'
                }
            }
        }
    }

    setInterval(processBarQueue, 3000)

    function LCG(seed) {
        function lcg(a) {
            return a * 48271 % 2147483647;
        };
        seed = seed ? lcg(seed) : lcg(Math.random())
        return function () {
            return (seed = lcg(seed)) / 2147483648
        }
    }

    var rand = LCG(135)

    function onClick(event) {
        var mouse3D = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) *
            2 + 1, 0);
        var raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse3D, camera);
        var intersects = raycaster.intersectObjects(scene.children);
        if (intersects.length > 0) {
            var point = new THREE.Vector3(intersects[0].point.x, entities[0].position.y, intersects[0].point.z)
            console.log('x: ' + Math.round(intersects[0].point.x) + ' , y: ' + Math.round(intersects[0].point.z))
            clickHistory.push({
                x: Math.round(intersects[0].point.x),
                z: Math.round(intersects[0].point.z)
            })
            console.log(JSON.stringify(clickHistory))
            if (event.altKey) {
                addFlag(point)
                path.push(point)
            }
        }

        if (event.ctrlKey) {
            reset();
        }
    }


    function loadModels() {
        loadModel(0)
    }

    function loadModel(index) {
        var loader = new THREE.SEA3D();
        loader.onProgress = function (e) {
            document.getElementById("loading-msg").innerHTML = "Loading model " + parseInt(index + 1) + " of " +
                characters.length //+ " ( " + parseInt(e.progress * 100) + "% )";
        };

        loader.onError = function (e) {
            index++;
            loadModel(index);
        };

        loader.onComplete = function (e) {

            characters[index].mesh = loader.meshes[0]
            characters[index].mesh.rotateY(Math.PI)

            if (index < characters.length - 1) {
                index++;
                loadModel(index);
            } else {
                loadAnimations()
            }
        }
        loader.load(characters[index].url);
    }


    function loadAnimation(index) {
        var loader = new THREE.SEA3D();
        loader.onProgress = function (e) {
            document.getElementById("loading-msg").innerHTML = "Loading animation " + parseInt(index + 1) + " of " +
                animations.length //+ " ( " + parseInt(e.progress * 100) + "% )";
        };

        loader.onError = function (e) {
            index++;
            loadAnimation(index);
        };

        loader.onComplete = function (e) {

            animations[index].data = loader.meshes[0].animations[0]

            if (index < animations.length - 1) {
                index++;
                loadAnimation(index);
            } else {
                var el = document.getElementById("loading-msg")
                el.parentNode.removeChild(el);
                init('container');
            }
        }
        loader.load(animations[index].url);
    }

    function loadAnimations() {

        loadAnimation(0)
    }

    function createFurnitureEntity(geometry, material, x, z, rotate) {
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.setY(geometry.parameters.height / 2);
        if (rotate) {
            mesh.rotateY(Math.PI / 4);
        }
        var entity = new SteeringEntity(mesh);
        entity.maxSpeed = 0;
        entity.lookAtDirection = false;
        entity.position.set(x, 0, z);
        furniture.push(entity)
        scene.add(entity);
    }

    function initFurniture() {
        furniture = []

        // Bar
        var barGeometry = new THREE.BoxGeometry(1000, 100, 100);
        var barGeometrySide = new THREE.BoxGeometry(100, 100, 450);
        var barMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,
            wireframe: false
        });
        createFurnitureEntity(barGeometry, barMaterial, 750, -1000, false)
        createFurnitureEntity(barGeometrySide, barMaterial, 1200, -1275, false)
        createFurnitureEntity(barGeometrySide, barMaterial, 300, -1275, false)



        // Walls
        var wallGeometryT1 = new THREE.BoxGeometry(20, 200, 350);
        var wallGeometryT2 = new THREE.BoxGeometry(20, 200, 450);
        var wallGeometryT3 = new THREE.BoxGeometry(1750, 200, 20);

        var wallGeometryB1 = new THREE.BoxGeometry(1180, 200, 20);
        var wallGeometryB2 = new THREE.BoxGeometry(20, 200, 250);
        var wallGeometryB3 = new THREE.BoxGeometry(20, 200, 250);
        var wallGeometryB4 = new THREE.BoxGeometry(20, 200, 650);

        var wallMaterial = new THREE.MeshBasicMaterial({
            color: 0x222222,
            wireframe: false
        });
        createFurnitureEntity(wallGeometryT1, wallMaterial, -500, -1325, false)
        createFurnitureEntity(wallGeometryT2, wallMaterial, -500, -500, false)
        createFurnitureEntity(wallGeometryT3, wallMaterial, -1375, -285, false)

        createFurnitureEntity(wallGeometryB1, wallMaterial, -1660, 180, false)
        createFurnitureEntity(wallGeometryB2, wallMaterial, -485, 770, true)
        createFurnitureEntity(wallGeometryB3, wallMaterial, -985, 270, true)
        createFurnitureEntity(wallGeometryB4, wallMaterial, -400, 1175, false)





        // Table
        var tableGeometrySquare = new THREE.BoxGeometry(200, 100, 200);
        var tableGeometryLong = new THREE.BoxGeometry(400, 100, 150);
        var tableGeometryLongBig = new THREE.BoxGeometry(1000, 100, 150);
        var tableMaterial = new THREE.MeshBasicMaterial({
            color: 0x555555,
            wireframe: false
        });

        var tablePositions = [
            [0, 150, tableGeometrySquare, false], // Main room, square tables, top
            [700, 150, tableGeometrySquare, false],
            [1400, 150, tableGeometrySquare, false],

            [0, 1000, tableGeometrySquare, false], // Main room, square tables, bottom
            [700, 1000, tableGeometrySquare, false],
            [1400, 1000, tableGeometrySquare, false],

            [350, 575, tableGeometryLong, false], // Main room, long tables
            [1050, 575, tableGeometryLong, false],

            [-1400, -1200, tableGeometryLongBig, false], // Top room
            [-1400, -600, tableGeometryLongBig, false],

            [-770, 1120, tableGeometrySquare, true], // Bottom room
            [-1170, 720, tableGeometrySquare, true],
            [-1570, 1120, tableGeometrySquare, true],
            [-1970, 720, tableGeometrySquare, true],

        ]
        tablePositions.forEach(function (tablePosition) {
            createFurnitureEntity(tablePosition[2], tableMaterial, tablePosition[0], tablePosition[1],
                tablePosition[3])
        })
    }

    function initEntities() {
        // Entities
        entities = []
        //entityPositions loaded from entity-positions.js
        entityPositions.forEach(function (entityPosition, i) {
            var randomChar = Math.floor(rand() * ((2 - 0) + 1) + 0);
            var clone = new THREE.SEA3D.SkinnedMesh(characters[randomChar].mesh.geometry,
                characters[
                    randomChar].mesh.material)
            for (var j = 0; j < animations.length; j++) {
                clone.animations.push(animations[j].data);
                clone.clips.push(animations[j].data);
                clone.animationsData[j] = animations[j].data;
            }
            clone.rotateY(Math.PI)
            clone.scale.set(1, 1, 1)
            clone.castShadow = true;
            var entity = new SteeringEntity(clone)
            entity._id = i
            entity.name = i
            entity.position.set(entityPosition.origin.x, 0, entityPosition.origin.z);
            entity.paths = {}

            entity.paths.toBar = []
            entity.paths.toBar.push(xZToPoint(entityPosition.origin))
            entityPosition.bar.forEach(function (path) {
                entity.paths.toBar.push(xZToPoint(path))
            })
            entity.paths.toBar.push(xZToPoint(fixedPositions.bar))

            entity.paths.fromBar = entity.paths.toBar.slice(0);
            entity.paths.fromBar = entity.paths.fromBar.reverse()


            entity.paths.toToilet = []
            entity.paths.toToilet.push(xZToPoint(entityPosition.origin))
            entityPosition.toilet.forEach(function (path) {
                entity.paths.toToilet.push(xZToPoint(path))
            })
            entity.paths.toToilet.push(xZToPoint(fixedPositions.toilet))

            entity.paths.fromToilet = entity.paths.toToilet.slice(0);
            entity.paths.fromToilet = entity.paths.fromToilet.reverse()


            entity.paths.toSmoke = []
            entity.paths.toSmoke.push(xZToPoint(entityPosition.origin))
            entityPosition.smoke.forEach(function (path) {
                entity.paths.toSmoke.push(xZToPoint(path))
            })
            entity.paths.toSmoke.push(xZToPoint(fixedPositions.smoke))

            entity.paths.fromSmoke = entity.paths.toSmoke.slice(0);
            entity.paths.fromSmoke = entity.paths.fromSmoke.reverse()

            entity.profile = selectProfile(rand())
            console.log(entity.profile.name)

            entity.action = {}
            entity.action.type = 'idle' //toBar, atBar, fromBar, toToilet, atToilet, fromToilet, toSmoke, atToilet, fromSmoke
            entity.action.drink = '' //beer, whiteWine, redWine, water, coke
            entityActionInit(entity, true)
            entities.push(entity)
            scene.add(entity)
        })
    }

    function entityActionInit(entity, initial) {
        // Get action from random and entity.profile.actionPropensity
        var action = getWeightedRandom(entity.profile.actionPropensity)
        var type = ''
        if (action === 'bar') {
            type = 'toBar'
        } else if (action === 'toilet') {
            type = 'toToilet'
        } else if (action === 'smoke') {
            type = 'toSmoke'
        }
        // If bar, get drink from random and entity.profile.drink
        var drink = action === 'bar' ? getWeightedRandom(entity.profile.drink) : ''

        // Get a waiting time from entity.profile.waiting
        var waitingTime = entity.profile.waiting[action]

        // Adjust waiting time with a level of random, ( for initial time only ?)
        if (initial) {
            waitingTime = randomIntFromRange(1 * 1000, waitingTime * 1000)
        }
        console.log('Entity:', entity.name, 'Init:', action, type, drink, waitingTime)
        // Add a timeout to bind to the waiting time to add the action

        setTimeout(function () {
            console.log('Entity:', entity.name, 'Action:', action, type, drink)
            entity.action.type = type
            entity.action.drink = drink
            entity.action.path = getPath(entity, type)
            // Bind the arrival, wait and return action in animate loop
        }, waitingTime);
    }

    function getPath(entity, type) {
        var pathToFollow
        if (type === 'toBar') {
            pathToFollow = entity.paths.toBar
        } else if (type === 'fromBar') {
            pathToFollow = entity.paths.fromBar
        } else if (type === 'toToilet') {
            pathToFollow = entity.paths.toToilet
        } else if (type === 'fromToilet') {
            pathToFollow = entity.paths.fromToilet
        } else if (type === 'toSmoke') {
            pathToFollow = entity.paths.toSmoke
        } else if (type === 'fromSmoke') {
            pathToFollow = entity.paths.fromSmoke
        }
        return pathToFollow
    }

    function randomIntFromRange(min, max) {
        return Math.floor(rand() * (max - min + 1) + min);
    }

    function getWeightedRandom(input) {
        var array = [];
        for (var item in input) {
            if (input.hasOwnProperty(item)) {
                for (var i = 0; i < input[item]; i++) {
                    array.push(item);
                }
            }
        }
        return array[Math.floor(rand() * array.length)];
    }

    function init(element) {
        container = document.getElementById(element);
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, params.size.x * 10);
        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer({
            alpha: true
        });
        renderer.setClearColor(0x333333, 0);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.gammaInput = true;
        renderer.gammaOutput = true;

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = 0;
        container.appendChild(renderer.domElement);

        camera.position.set(0, params.size.x * 2, params.size.z * 2);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.maxPolarAngle = Math.PI * 0.5;
        controls.minDistance = 100;
        controls.maxDistance = 20000;

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.bottom = '0px';
        stats.domElement.style.left = '180px'
        stats.domElement.style.zIndex = 100;
        container.appendChild(stats.domElement);

        clock = new THREE.Clock();


        //Lights
        var spotLight = new THREE.SpotLight(0xffffff, 5.0);
        spotLight.position.set(0, params.size.x, 0);
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 1024;
        spotLight.shadow.mapSize.height = 1024;
        spotLight.angle = 1;
        spotLight.penumbra = 0.5;
        spotLight.decay = 2;
        spotLight.distance = params.size.x * 2;


        var ambient = new THREE.AmbientLight(0xFFFFFF);
        ambient.intensity = 0.25
        scene.add(spotLight);
        scene.add(ambient);

        // Floor
        var floorGeometry = new THREE.CubeGeometry(params.size.x * 2, params.size.z * 2, 1, 32);
        var floorMaterial = new THREE.MeshPhongMaterial({
            color: 0x4DA6FF
        });
        var floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.receiveShadow = true;
        floor.rotation.x = -Math.PI * .5;
        scene.add(floor);

        var toiletGeometry = new THREE.CubeGeometry(500, 500, 1, 32);
        var toiletMaterial = new THREE.MeshPhongMaterial({
            color: 0xFFA64D
        });
        var toilet1 = new THREE.Mesh(toiletGeometry, toiletMaterial);
        toilet1.receiveShadow = true;
        toilet1.rotation.x = -Math.PI * .5;
        toilet1.position.set(2500, 0, 200);
        scene.add(toilet1);

        var toilet1 = new THREE.Mesh(toiletGeometry, toiletMaterial);
        toilet1.receiveShadow = true;
        toilet1.rotation.x = -Math.PI * .5;
        toilet1.position.set(-2500, 0, -50);
        scene.add(toilet1);

        initFurniture()




        path = []
        flags = []
        arrows = []



        initEntities()



        //Plane boundaries (do not cross)
        boundaries = new THREE.Box3(new THREE.Vector3(-params.size.x, 0, -params.size.z), new THREE.Vector3(params.size
            .x, 0,
            params.size.z));


        //Gui
        var gui = new dat.GUI();

        // var quantity = gui.add(params, 'numEntities', 1, 100).name("Num Of Entities");
        // quantity.onFinishChange(function (value) {
        //     for (var i = 0; i < entities.length; i++) {
        //         entities[i].mesh.traverse(function (obj) {
        //             scene.remove(obj);
        //             if (obj.geometry)
        //                 obj.geometry.dispose();
        //             if (obj.material)
        //                 obj.material.dispose();
        //             if (obj.mesh)
        //                 obj.mesh.dispose();
        //             if (obj.texture)
        //                 obj.texture.dispose();

        //         });
        //         scene.remove(entities[i])

        //     }


        // });

        gui.add(params, 'maxSpeed', 2, 20).name('Max Speed').step(1);
        gui.add(params, 'maxForce', 1, 20).name('Max Force').step(1);
        gui.add(params, 'thresholdRadius', 10, 500).name('Threshold Radius').step(1);
        gui.add(params, 'avoidDistance', 10, 2000).name('Avoid Distance').step(1);
        gui.add(params, 'loop').name('Loop');
        gui.add(params, 'avoid').name('Avoid');

        var toBarGui = gui.add(params, 'toBar').name('To Bar');
        toBarGui.onFinishChange(function (value) {
            reset()
        })
        var fromBarGui = gui.add(params, 'fromBar').name('From Bar');
        fromBarGui.onFinishChange(function (value) {
            reset()
        })
        var toToiletGui = gui.add(params, 'toToilet').name('To Toilet');
        toToiletGui.onFinishChange(function (value) {
            reset()
        })
        var fromToiletGui = gui.add(params, 'fromToilet').name('From Toilet');
        fromToiletGui.onFinishChange(function (value) {
            reset()
        })
        var toSmokeGui = gui.add(params, 'toSmoke').name('To Smoke');
        toSmokeGui.onFinishChange(function (value) {
            reset()
        })
        var fromSmokeGui = gui.add(params, 'fromSmoke').name('From Smoke');
        fromBarGui.onFinishChange(function (value) {
            reset()
        })
        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousedown', onClick, true);
        animate();
    }

    function xZToPoint(xZ) {
        return new THREE.Vector3(xZ.x, 0, xZ.z)
    }

    function reset() {
        var i;
        for (i = 0; i < flags.length; i++)
            scene.remove(flags[i])
        for (i = 0; i < arrows.length; i++)
            scene.remove(arrows[i])
        path = []
        flags = []
        arrows = [];
        for (var i = 0; i < entities.length; i++) {
            entities[i].pathIndex = 0
        }

    }

    function addFlag(position) {
        addArrow(position)
        var flagGeometry = new THREE.CylinderGeometry(10, 10, 300, 32);
        var flagMaterial = new THREE.MeshPhongMaterial({
            color: 0x002DB2
        });
        var flag = new THREE.Mesh(flagGeometry, flagMaterial);
        flag.castShadow = true;
        flag.position.set(position.x, 150, position.z);
        scene.add(flag);
        flags.push(flag)

    }

    function addArrow(position) {
        if (path.length > 0) {
            var start = new THREE.Vector3(path[path.length - 1].x, path[path.length - 1].y, path[path.length - 1].z);
            var distance = path[path.length - 1].distanceTo(position)
            var direction = position.clone().sub(path[path.length - 1]).normalize()
            var arrow = new THREE.ArrowHelper(direction, start, distance, 0x002DB2, distance - 1, 100)
            arrow.cone.material.transparent = true;
            arrow.cone.material.opacity = 0.5;
            scene.add(arrow)
            arrows.push(arrow)
        }
    }



    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {

        requestAnimationFrame(animate);


        var delta = clock.getDelta();
        THREE.SEA3D.AnimationHandler.update(delta);
        controls.update();


        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i]
            entity.maxSpeed = params.maxSpeed;
            entity.maxForce = params.maxForce;

            entity.setAnimation()

            if (entity.action.path && entity.action.path.length > 0) {
                entity.followPathAndReturn(entity.action.path, params.loop, params.thresholdRadius);
                entity.lookWhereGoing(true)
                if (params.avoid) {
                    entity.avoidDistance = params.avoidDistance;
                    entity.avoid(entities)
                    entity.avoid(furniture)
                }
            } else {
                entity.idle()
            }

            entity.update();

        }

        renderer.render(scene, camera);
        stats.update();

    }
    Entity.prototype.setAnimation = function () {
        if (this.velocity.length() <= 1)
            this.mesh.play(1, 0.5); //Idle

        else if (this.velocity.length() > 1 && this.velocity.length() <= 8)
            this.mesh.play(2, 0.5) //Walk

        else if (this.velocity.length() > 8 && this.velocity.length() <= 12)
            this.mesh.play(3, 0.5) //Jog

        else if (this.velocity.length() > 12)
            this.mesh.play(4, 0.5) //Run
    }
    SteeringEntity.prototype.followPathAndReturn = function (path, loop, thresholdRadius = 1) {
        var wayPoint = path[this.pathIndex]
        if (wayPoint == null)
            return;
        if (this.position.distanceTo(wayPoint) < thresholdRadius) {
            if (this.pathIndex >= path.length - 1) {
                console.log('Entity:', this.name, 'Arrived:', this.action.type)
                this.action.path = []
                if (this.action.type === 'toBar') {
                    this.action.type === 'atBar'
                    //Send drink to bartender and wait, return will be in bartender loop
                    barQueue.push({
                        id: this._id,
                        name: this.name,
                        drink: this.action.drink,
                        status: 'waiting'
                    })
                } else if (this.action.type === 'toToilet') {
                    this.action.type === 'atToilet'
                    var idleTime = 20
                    var entity = this
                    setTimeout(function () {
                        entity.pathIndex = 0
                        entity.action.type = 'fromToilet'
                        entity.action.path = getPath(entity, entity.action.type)
                        console.log('Entity:', entity.name, 'Return:', entity.action.type)
                    }, idleTime);
                } else if (this.action.type === 'toSmoke') {
                    this.action.type === 'atSmoke'
                    var idleTime = 30
                    var entity = this
                    setTimeout(function () {
                        entity.pathIndex = 0
                        entity.action.type = 'fromSmoke'
                        entity.action.path = getPath(entity, entity.action.type)
                        console.log('Entity:', entity.name, 'Return:', entity.action.type)
                    }, idleTime);
                }


            } else {
                this.pathIndex++
            }
        }
        if (this.pathIndex >= path.length - 1 && !loop)
            this.arrive(wayPoint)
        else
            this.seek(wayPoint)
    }
</script>

<body onload="loadModels()">
    <div id="container"></div>
    <div id="msg">
        <span style="color:#BFFF00; font-weight: bold">PATH FOLLOW:</span>
        <br>ALT + Click to add points to path.
        <br>CTRL + Click to reset.</div>

    <div id="loading-msg"></div>
    <a href="https://github.com/erosmarcon/three-steer/blob/master/examples/animated/PathFollow.html" target="_blank">
        <div class="view-source">View source</div>
    </a>
</body>

</html>