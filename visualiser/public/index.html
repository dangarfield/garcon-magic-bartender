<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Garcon - Magic Bartender - Visualiser</title>
    <script src="/public/js/libs/dat.gui.min.js"></script>
    <script src="/public/js/libs/stats.min.js"></script>
    <script src="/public/js/libs/three.min.js"></script>
    <script src="/public/js/libs/socket.io.slim.js"></script>
    <script src="/public/js/libs/axios.min.js"></script>
    <script src="/public/js/threejs/sea3d/SEA3D.js"></script>
    <script src="/public/js/threejs/sea3d/SEA3DLZMA.js"></script>
    <script src="/public/js/threejs/sea3d/SEA3DLoader.js"></script>
    <script src="/public/js/threejs/controls/OrbitControls.js"></script>
    <script src="/public/js/ThreeSteer.js"></script>
    <script src="/public/js/entity-positions.js"></script>
    <script src="/public/js/entity-profiles.js"></script>
    <link rel="stylesheet" type="text/css" href="/public/css/main.css" />
    <link rel="stylesheet" type="text/css" href="/public/css/gui.css" />
</head>
<script>
    var container;
    var camera;

    var scene, renderer;
    var clock;
    var controls;
    var stats;

    var boundaries;
    var entities;
    var furniture;
    var params;
    var mesh;

    var path;
    var arrows, flags;

    var characters = [{
            index: 0,
            name: "white",
            url: "/public/models/avatar_white.tjs.sea"
        },
        {
            index: 1,
            name: "red",
            url: "/public/models/avatar_red.tjs.sea"
        },
        {
            index: 2,
            name: "black",
            url: "/public/models/avatar_black.tjs.sea"
        }
    ];

    var animations = [{
            index: 0,
            name: "idle",
            url: "/public/models/animations/idle.tjs.sea"
        },
        {
            index: 1,
            name: "walk",
            url: "/public/models/animations/walk.tjs.sea"
        },
        {
            index: 2,
            name: "jog",
            url: "/public/models/animations/jog.tjs.sea"
        },
        {
            index: 3,
            name: "run",
            url: "/public/models/animations/run.tjs.sea"
        }
    ];

    params = {
        maxSpeed: 5,
        maxForce: 3,
        numEntities: 72,
        thresholdRadius: 50,
        loop: false,
        avoid: false,
        avoidDistance: 10,
        size: {
            x: 2250,
            z: 1500
        },
        start: false
    }


    var socket = io.connect('http://localhost:5100')

    var clickHistory = []

    var barQueue = []
    var movementList = []
    var connectedBartenders = []

    var predictionResults = {
        position: {
            correct: 0,
            wrong: 0
        },
        drink: {
            correct: 0,
            wrong: 0
        }
    }

    function processBarQueue() {

        if (connectedBartenders.length > 0) {
            console.log('Bar queue is being processed by connected bartenders', connectedBartenders)
        } else if (barQueue.length > 0) {
            console.log('Processing bar queue with default', barQueue)
            var order = barQueue[0]
            if (order.status == 'waiting') {
                order.status = 'serving'
                renderBarQueue()
            } else if (order.status == 'serving') {
                order.status = 'DONE'
                var entity = entities[order.id]
                console.log('Served entity: ID:', order.id, 'Name:', order.name, 'Entity:', entity.name)
                triggerServed(entity)
            }
        }
    }

    function triggerServed(entity) {
        barQueue.shift()
        entity.pathIndex = 0
        entity.action.type = 'fromBar'
        entity.action.path = getPath(entity, entity.action.type)
        console.log('Entity:', entity.name, 'Return:', entity.action.type)
        if (barQueue.length > 0) {
            barQueue[0].status = 'serving'
        }
        renderBarQueue()
    }

    setInterval(processBarQueue, 3000) // Default speed for serving a customer, if there are any bartenders connected, this will not apply

    function renderBarQueue() {
        console.log('renderBarQueue', barQueue)
        var queueParent = document.getElementById('barQueue');
        var oldQueue = document.getElementById('barQueueItems');
        var newQueue = document.createElement('div')
        newQueue.id = 'barQueueItems'

        barQueue.forEach(function (item) {
            var p = document.createElement('p')
            var text = 'ID: ' + item.id + ' Name: ' + item.name
            text = text + ' Status: ' + item.status
            // if (item.status == 'serving') {
            text = text + ' Drink: ' + item.drink
            // }
            if (item.prediction) {
                text = text + ' Prediction: ' + item.prediction
            }
            p.textContent = text
            newQueue.appendChild(p)
        })
        queueParent.removeChild(oldQueue);
        queueParent.appendChild(newQueue);
    }

    function renderMovementList() {
        console.log('renderMovementList')
        var queueParent = document.getElementById('movementQueue');
        var oldQueue = document.getElementById('movementQueueItems');
        var newQueue = document.createElement('div')
        newQueue.id = 'movementQueueItems'

        movementList.forEach(function (item) {
            var p = document.createElement('p')
            var text = 'ID: ' + item.id + ' Name: ' + item.name + ' Location: ' + item.location
            if (item.prediction.location) {
                text = text + ' Prediction: ' + item.prediction.location
                if (item.prediction.location === 'bar' && item.prediction.drink) {
                    text = text + ' ' + item.prediction.drink
                }
            }
            p.textContent = text
            newQueue.appendChild(p)
        })
        queueParent.removeChild(oldQueue);
        queueParent.appendChild(newQueue);
    }

    function renderPredictionResults() {
        console.log('renderPredictionResults')
        var parent = document.getElementById('predictionResults');
        var oldItems = document.getElementById('predictionResultsItems');
        var newItems = document.createElement('div')
        newItems.id = 'predictionResultsItems'

        var pPara = document.createElement('p')
        var pTotal = predictionResults.position.correct + predictionResults.position.wrong
        var pPercent = Math.round((predictionResults.position.correct * 100) / pTotal)
        var pText = 'Movements: ' + predictionResults.position.correct + ' of ' + (predictionResults.position.correct +
            predictionResults.position.wrong) + ' - ' + pPercent + '%'
        pPara.textContent = pText
        newItems.appendChild(pPara)

        var dPara = document.createElement('p')
        var dTotal = predictionResults.drink.correct + predictionResults.drink.wrong
        var dPercent = Math.round((predictionResults.drink.correct * 100) / dTotal)
        var dText = 'Drinks: ' + predictionResults.drink.correct + ' of ' + (predictionResults.drink.correct +
            predictionResults.drink.wrong) + ' - ' + dPercent + '%'
        dPara.textContent = dText
        newItems.appendChild(dPara)

        parent.removeChild(oldItems);
        parent.appendChild(newItems);
    }

    function renderConnectedBartenders() {
        console.log('renderConnectedBartenders')

        var queueParent = document.getElementById('connectedBartenders');
        var oldQueue = document.getElementById('connectedBartendersItems');
        var newQueue = document.createElement('div')
        newQueue.id = 'connectedBartendersItems'

        connectedBartenders.forEach(function (bartender) {
            var p = document.createElement('p')
            var text = bartender.name + ' - ' + bartender.description
            p.textContent = text
            newQueue.appendChild(p)
        })
        if (connectedBartenders.length == 0) {
            var p = document.createElement('p')
            var text = 'None - Auto-serve within 3 seconds'
            p.textContent = text
            newQueue.appendChild(p)

        }
        queueParent.removeChild(oldQueue);
        queueParent.appendChild(newQueue);
    }

    function LCG(seed) {
        function lcg(a) {
            return a * 48271 % 2147483647;
        };
        seed = seed ? lcg(seed) : lcg(Math.random())
        return function () {
            return (seed = lcg(seed)) / 2147483648
        }
    }

    var rand = LCG(135)

    function onClick(event) {
        var mouse3D = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) *
            2 + 1, 0);
        var raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse3D, camera);
        var intersects = raycaster.intersectObjects(scene.children);
        if (intersects.length > 0) {
            var point = new THREE.Vector3(intersects[0].point.x, entities[0].position.y, intersects[0].point.z)
            console.log('x: ' + Math.round(intersects[0].point.x) + ' , y: ' + Math.round(intersects[0].point.z))
            clickHistory.push({
                x: Math.round(intersects[0].point.x),
                z: Math.round(intersects[0].point.z)
            })
            console.log(JSON.stringify(clickHistory))
            if (event.altKey) {
                addFlag(point)
                path.push(point)
            }
        }

        if (event.ctrlKey) {
            reset();
        }
    }


    function loadModels() {
        loadModel(0)
    }

    function loadModel(index) {
        var loader = new THREE.SEA3D();
        loader.onProgress = function (e) {
            document.getElementById("loading-msg").innerHTML = "Loading model " + parseInt(index + 1) + " of " +
                characters.length //+ " ( " + parseInt(e.progress * 100) + "% )";
        };

        loader.onError = function (e) {
            index++;
            loadModel(index);
        };

        loader.onComplete = function (e) {

            characters[index].mesh = loader.meshes[0]
            characters[index].mesh.rotateY(Math.PI)

            if (index < characters.length - 1) {
                index++;
                loadModel(index);
            } else {
                loadAnimations()
            }
        }
        loader.load(characters[index].url);
    }


    function loadAnimation(index) {
        var loader = new THREE.SEA3D();
        loader.onProgress = function (e) {
            document.getElementById("loading-msg").innerHTML = "Loading animation " + parseInt(index + 1) + " of " +
                animations.length //+ " ( " + parseInt(e.progress * 100) + "% )";
        };

        loader.onError = function (e) {
            index++;
            loadAnimation(index);
        };

        loader.onComplete = function (e) {

            animations[index].data = loader.meshes[0].animations[0]

            if (index < animations.length - 1) {
                index++;
                loadAnimation(index);
            } else {
                var el = document.getElementById("loading-msg")
                el.parentNode.removeChild(el);
                init('container');
            }
        }
        loader.load(animations[index].url);
    }

    function loadAnimations() {

        loadAnimation(0)
    }

    function createFurnitureEntity(geometry, material, x, z, rotate) {
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.setY(geometry.parameters.height / 2);
        if (rotate) {
            mesh.rotateY(Math.PI / 4);
        }
        var entity = new SteeringEntity(mesh);
        entity.maxSpeed = 0;
        entity.lookAtDirection = false;
        entity.position.set(x, 0, z);
        furniture.push(entity)
        scene.add(entity);
    }

    function initFurniture() {
        furniture = []

        // Bar
        var barGeometry = new THREE.BoxGeometry(1000, 100, 100);
        var barGeometrySide = new THREE.BoxGeometry(100, 100, 450);
        var barMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,
            wireframe: false
        });
        createFurnitureEntity(barGeometry, barMaterial, 750, -1000, false)
        createFurnitureEntity(barGeometrySide, barMaterial, 1200, -1275, false)
        createFurnitureEntity(barGeometrySide, barMaterial, 300, -1275, false)



        // Walls
        var wallGeometryT1 = new THREE.BoxGeometry(20, 200, 350);
        var wallGeometryT2 = new THREE.BoxGeometry(20, 200, 450);
        var wallGeometryT3 = new THREE.BoxGeometry(1750, 200, 20);

        var wallGeometryB1 = new THREE.BoxGeometry(1180, 200, 20);
        var wallGeometryB2 = new THREE.BoxGeometry(20, 200, 250);
        var wallGeometryB3 = new THREE.BoxGeometry(20, 200, 250);
        var wallGeometryB4 = new THREE.BoxGeometry(20, 200, 650);

        var wallMaterial = new THREE.MeshBasicMaterial({
            color: 0x222222,
            wireframe: false
        });
        createFurnitureEntity(wallGeometryT1, wallMaterial, -500, -1325, false)
        createFurnitureEntity(wallGeometryT2, wallMaterial, -500, -500, false)
        createFurnitureEntity(wallGeometryT3, wallMaterial, -1375, -285, false)

        createFurnitureEntity(wallGeometryB1, wallMaterial, -1660, 180, false)
        createFurnitureEntity(wallGeometryB2, wallMaterial, -485, 770, true)
        createFurnitureEntity(wallGeometryB3, wallMaterial, -985, 270, true)
        createFurnitureEntity(wallGeometryB4, wallMaterial, -400, 1175, false)





        // Table
        var tableGeometrySquare = new THREE.BoxGeometry(200, 100, 200);
        var tableGeometryLong = new THREE.BoxGeometry(400, 100, 150);
        var tableGeometryLongBig = new THREE.BoxGeometry(1000, 100, 150);
        var tableMaterial = new THREE.MeshBasicMaterial({
            color: 0x555555,
            wireframe: false
        });

        var tablePositions = [
            [0, 150, tableGeometrySquare, false], // Main room, square tables, top
            [700, 150, tableGeometrySquare, false],
            [1400, 150, tableGeometrySquare, false],

            [0, 1000, tableGeometrySquare, false], // Main room, square tables, bottom
            [700, 1000, tableGeometrySquare, false],
            [1400, 1000, tableGeometrySquare, false],

            [350, 575, tableGeometryLong, false], // Main room, long tables
            [1050, 575, tableGeometryLong, false],

            [-1400, -1200, tableGeometryLongBig, false], // Top room
            [-1400, -600, tableGeometryLongBig, false],

            [-770, 1120, tableGeometrySquare, true], // Bottom room
            [-1170, 720, tableGeometrySquare, true],
            [-1570, 1120, tableGeometrySquare, true],
            [-1970, 720, tableGeometrySquare, true],

        ]
        tablePositions.forEach(function (tablePosition) {
            createFurnitureEntity(tablePosition[2], tableMaterial, tablePosition[0], tablePosition[1],
                tablePosition[3])
        })
    }

    function initEntities() {
        // Entities
        entities = []
        //entityPositions loaded from entity-positions.js
        entityPositions.forEach(function (entityPosition, i) {
            var randomChar = Math.floor(rand() * ((2 - 0) + 1) + 0);
            var clone = new THREE.SEA3D.SkinnedMesh(characters[randomChar].mesh.geometry,
                characters[
                    randomChar].mesh.material)
            for (var j = 0; j < animations.length; j++) {
                clone.animations.push(animations[j].data);
                clone.clips.push(animations[j].data);
                clone.animationsData[j] = animations[j].data;
            }
            clone.rotateY(Math.PI)
            clone.scale.set(1, 1, 1)
            clone.castShadow = true;
            var entity = new SteeringEntity(clone)
            entity._id = i
            entity.name = i
            entity.origin = entityPosition.origin
            entity.position.set(entityPosition.origin.x, 0, entityPosition.origin.z);
            entity.paths = {}

            entity.paths.toBar = []
            entity.paths.toBar.push(xZToPoint(entityPosition.origin))
            entityPosition.bar.forEach(function (path) {
                entity.paths.toBar.push(xZToPoint(path))
            })
            entity.paths.toBar.push(xZToPoint(fixedPositions.bar))

            entity.paths.fromBar = entity.paths.toBar.slice(0);
            entity.paths.fromBar = entity.paths.fromBar.reverse()


            entity.paths.toToilet = []
            entity.paths.toToilet.push(xZToPoint(entityPosition.origin))
            entityPosition.toilet.forEach(function (path) {
                entity.paths.toToilet.push(xZToPoint(path))
            })
            entity.paths.toToilet.push(xZToPoint(fixedPositions.toilet))

            entity.paths.fromToilet = entity.paths.toToilet.slice(0);
            entity.paths.fromToilet = entity.paths.fromToilet.reverse()


            entity.paths.toSmoke = []
            entity.paths.toSmoke.push(xZToPoint(entityPosition.origin))
            entityPosition.smoke.forEach(function (path) {
                entity.paths.toSmoke.push(xZToPoint(path))
            })
            entity.paths.toSmoke.push(xZToPoint(fixedPositions.smoke))

            entity.paths.fromSmoke = entity.paths.toSmoke.slice(0);
            entity.paths.fromSmoke = entity.paths.fromSmoke.reverse()

            entity.profile = selectProfile(rand())
            console.log(entity.profile.name)

            entity.action = {}
            entity.action.type = 'idle' //toBar, atBar, fromBar, toToilet, atToilet, fromToilet, toSmoke, atToilet, fromSmoke
            entity.action.drink = '' //beer, whiteWine, redWine, water, coke
            entity.action.positionList = []
            entity.prediction = {}
            entityActionInit(entity, true)
            entities.push(entity)
            scene.add(entity)
        })
    }

    function entityActionInit(entity, initial) {
        // Get action from random and entity.profile.actionPropensity
        var action = getWeightedRandom(entity.profile.actionPropensity)
        var type = ''
        if (action === 'bar') {
            type = 'toBar'
        } else if (action === 'toilet') {
            type = 'toToilet'
        } else if (action === 'smoke') {
            type = 'toSmoke'
        }
        // If bar, get drink from random and entity.profile.drink
        var drink = action === 'bar' ? getWeightedRandom(entity.profile.drink) : ''

        // Get a waiting time from entity.profile.waiting
        var waitingTime = entity.profile.waiting[action] * 1000

        // Adjust waiting time with a level of random, ( for initial time only ?)
        if (initial) {
            waitingTime = randomIntFromRange(1 * 1000, waitingTime)
        }
        console.log('Entity:', entity.name, 'Init:', action, type, drink, waitingTime)
        // Add a timeout to bind to the waiting time to add the action

        setTimeout(function () {
            console.log('Entity:', entity.name, 'Action:', action, type, drink)
            entity.action.type = type
            entity.action.drink = drink
            entity.action.path = getPath(entity, type)
            // Bind the arrival, wait and return action in animate loop
        }, waitingTime);
    }

    function getPath(entity, type) {
        var pathToFollow
        if (type === 'toBar') {
            pathToFollow = entity.paths.toBar
        } else if (type === 'fromBar') {
            pathToFollow = entity.paths.fromBar
        } else if (type === 'toToilet') {
            pathToFollow = entity.paths.toToilet
        } else if (type === 'fromToilet') {
            pathToFollow = entity.paths.fromToilet
        } else if (type === 'toSmoke') {
            pathToFollow = entity.paths.toSmoke
        } else if (type === 'fromSmoke') {
            pathToFollow = entity.paths.fromSmoke
        }
        return pathToFollow
    }

    function randomIntFromRange(min, max) {
        return Math.floor(rand() * (max - min + 1) + min);
    }

    function getWeightedRandom(input) {
        var array = [];
        for (var item in input) {
            if (input.hasOwnProperty(item)) {
                for (var i = 0; i < input[item]; i++) {
                    array.push(item);
                }
            }
        }
        return array[Math.floor(rand() * array.length)];
    }

    function init(element) {
        container = document.getElementById(element);
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, params.size.x * 10);
        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer({
            alpha: true
        });
        renderer.setClearColor(0x333333, 0);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.gammaInput = true;
        renderer.gammaOutput = true;

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = 0;
        container.appendChild(renderer.domElement);

        camera.position.set(0, params.size.x * 2, params.size.z * 2);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.maxPolarAngle = Math.PI * 0.5;
        controls.minDistance = 100;
        controls.maxDistance = 20000;

        stats = new Stats()
        stats.domElement.style.position = 'absolute'
        stats.domElement.style.top = '20px'
        stats.domElement.style.left = null
        stats.domElement.style.right = '280px'
        stats.domElement.style.zIndex = 100;
        document.body.appendChild(stats.domElement);

        clock = new THREE.Clock();


        //Lights
        var spotLight = new THREE.SpotLight(0xffffff, 5.0);
        spotLight.position.set(0, params.size.x, 0);
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 1024;
        spotLight.shadow.mapSize.height = 1024;
        spotLight.angle = 1;
        spotLight.penumbra = 0.5;
        spotLight.decay = 2;
        spotLight.distance = params.size.x * 2;


        var ambient = new THREE.AmbientLight(0xFFFFFF);
        ambient.intensity = 0.25
        scene.add(spotLight);
        scene.add(ambient);

        // Floor
        var floorGeometry = new THREE.CubeGeometry(params.size.x * 2, params.size.z * 2, 1, 32);
        var floorMaterial = new THREE.MeshPhongMaterial({
            color: 0x4DA6FF
        });
        var floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.receiveShadow = true;
        floor.rotation.x = -Math.PI * .5;
        scene.add(floor);

        var toiletGeometry = new THREE.CubeGeometry(500, 500, 1, 32);
        var toiletMaterial = new THREE.MeshPhongMaterial({
            color: 0xFFA64D
        });
        var toilet1 = new THREE.Mesh(toiletGeometry, toiletMaterial);
        toilet1.receiveShadow = true;
        toilet1.rotation.x = -Math.PI * .5;
        toilet1.position.set(2500, 0, 200);
        scene.add(toilet1);

        var toilet1 = new THREE.Mesh(toiletGeometry, toiletMaterial);
        toilet1.receiveShadow = true;
        toilet1.rotation.x = -Math.PI * .5;
        toilet1.position.set(-2500, 0, -50);
        scene.add(toilet1);

        initFurniture()




        path = []
        flags = []
        arrows = []



        initEntities()



        //Plane boundaries (do not cross)
        boundaries = new THREE.Box3(new THREE.Vector3(-params.size.x, 0, -params.size.z), new THREE.Vector3(params.size
            .x, 0,
            params.size.z));


        //Gui
        var gui = new dat.GUI();

        // var quantity = gui.add(params, 'numEntities', 1, 100).name("Num Of Entities");
        // quantity.onFinishChange(function (value) {
        //     for (var i = 0; i < entities.length; i++) {
        //         entities[i].mesh.traverse(function (obj) {
        //             scene.remove(obj);
        //             if (obj.geometry)
        //                 obj.geometry.dispose();
        //             if (obj.material)
        //                 obj.material.dispose();
        //             if (obj.mesh)
        //                 obj.mesh.dispose();
        //             if (obj.texture)
        //                 obj.texture.dispose();

        //         });
        //         scene.remove(entities[i])

        //     }


        // });

        // gui.add(params, 'maxSpeed', 2, 20).name('Max Speed').step(1);
        // gui.add(params, 'maxForce', 1, 20).name('Max Force').step(1);
        // gui.add(params, 'thresholdRadius', 10, 500).name('Threshold Radius').step(1);
        // gui.add(params, 'avoidDistance', 10, 2000).name('Avoid Distance').step(1);
        // gui.add(params, 'loop').name('Loop');
        // gui.add(params, 'avoid').name('Avoid');
        // var startGui = gui.add(params, 'start').name('Start');
        // startGui.onFinishChange(function (value) {
        //     entities.forEach(function (entity) {
        // entityActionInit(entity, true)
        //     })
        // })
        // var toBarGui = gui.add(params, 'toBar').name('To Bar');
        // toBarGui.onFinishChange(function (value) {
        //     reset()
        // })
        // var fromBarGui = gui.add(params, 'fromBar').name('From Bar');
        // fromBarGui.onFinishChange(function (value) {
        //     reset()
        // })
        // var toToiletGui = gui.add(params, 'toToilet').name('To Toilet');
        // toToiletGui.onFinishChange(function (value) {
        //     reset()
        // })
        // var fromToiletGui = gui.add(params, 'fromToilet').name('From Toilet');
        // fromToiletGui.onFinishChange(function (value) {
        //     reset()
        // })
        // var toSmokeGui = gui.add(params, 'toSmoke').name('To Smoke');
        // toSmokeGui.onFinishChange(function (value) {
        //     reset()
        // })
        // var fromSmokeGui = gui.add(params, 'fromSmoke').name('From Smoke');
        // fromBarGui.onFinishChange(function (value) {
        //     reset()
        // })
        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousedown', onClick, true);
        animate();
    }

    function xZToPoint(xZ) {
        return new THREE.Vector3(xZ.x, 0, xZ.z)
    }

    function reset() {
        var i;
        for (i = 0; i < flags.length; i++)
            scene.remove(flags[i])
        for (i = 0; i < arrows.length; i++)
            scene.remove(arrows[i])
        path = []
        flags = []
        arrows = [];
        for (var i = 0; i < entities.length; i++) {
            entities[i].pathIndex = 0
        }

    }

    function addFlag(position) {
        addArrow(position)
        var flagGeometry = new THREE.CylinderGeometry(10, 10, 300, 32);
        var flagMaterial = new THREE.MeshPhongMaterial({
            color: 0x002DB2
        });
        var flag = new THREE.Mesh(flagGeometry, flagMaterial);
        flag.castShadow = true;
        flag.position.set(position.x, 150, position.z);
        scene.add(flag);
        flags.push(flag)

    }

    function addArrow(position) {
        if (path.length > 0) {
            var start = new THREE.Vector3(path[path.length - 1].x, path[path.length - 1].y, path[path.length - 1].z);
            var distance = path[path.length - 1].distanceTo(position)
            var direction = position.clone().sub(path[path.length - 1]).normalize()
            var arrow = new THREE.ArrowHelper(direction, start, distance, 0x002DB2, distance - 1, 100)
            arrow.cone.material.transparent = true;
            arrow.cone.material.opacity = 0.5;
            scene.add(arrow)
            arrows.push(arrow)
        }
    }



    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    var frameNo = 0

    function broadcastPositionData(entity) {
        var positionList = entity.action.positionList

        var location
        var drink = entity.action.drink
        if (entity.action.type === 'toBar') {
            location = 'bar'
        } else if (entity.action.type === 'toToilet') {
            location = 'toilet'
        } else if (entity.action.type === 'toSmoke') {
            location = 'smoke'
        }
        entity.action.positionList = []
        var data = {
            id: entity._id,
            name: entity.name,
            positions: positionList,
            location: location,
            drink: drink
        }
        console.log('Entity:', entity.name, 'broadcastPositionData', data)
        //TODO - Send this to server to generate training data
        socket.emit('finishedJourney', data);
        return data
    }


    async function getPrediction(modelType, features) {
        const url = 'http://localhost:5101/predict/' + modelType + '?features=' + features.join(',')
        //   console.log('getMovementPrediction url', url)
        const res = await axios(url)
        //   console.log('getMovementPrediction res.data', res.data)
        return res.data
    }

    function positionPredictionRequest(entity, positionList) {
        if (!entity.prediction.position) {
            var positions = positionList.splice(-5)
            getPrediction('position', positions).then(function (res) {
                console.log('Movement prediction result', entity._id, res)
                if (res.score > 0.8) {
                    entity.prediction.position = res.result
                    movementList.forEach(function (item) {
                        if (item.id === entity._id) {
                            console.log('positionPredictionRequest item', entity, item)
                            item.prediction.location = res.result
                            renderMovementList()
                            return null
                        }
                    })
                    console.log('Position prediction result updated', entity)
                    if (entity.prediction.position && entity.prediction.position === 'bar' && entity.prediction
                        .drink) {
                        sendInfoToBartender(entity._id, entity.name, 'incoming', entity.action.drink, entity.prediction
                            .drink)
                    }
                }
            })
        }
    }

    function drinkPredictionRequest(entity, positionList) {
        if (!entity.prediction.drink) {
            getPrediction('drink', [entity.origin.x, entity.origin.z]).then(function (res) {
                console.log('Drink prediction result', entity._id, res)
                if (res.score > 0.8) {
                    entity.prediction.drink = res.result
                    barQueue.forEach(function (item) {
                        if (item.id === entity._id) {
                            console.log('drinkPredictionRequest item', entity, item)
                            item.prediction = res.result
                            renderBarQueue()
                            return null
                        }
                    })
                    movementList.forEach(function (item) {
                        if (item.id === entity._id) {
                            console.log('positionPredictionRequest item', entity, item)
                            item.prediction.drink = res.result
                            renderMovementList()
                            return null
                        }
                    })
                    console.log('Drink prediction result updated', entity)
                    if (entity.prediction.position && entity.prediction.position === 'bar' && entity.prediction
                        .drink) {
                        sendInfoToBartender(entity._id, entity.name, 'incoming', entity.prediction.drink)
                    }
                }
            })
        }
    }

    function updateMovementDataAndPredict(entity) {
        var location = null
        if (entity.action.type === 'toBar') {
            location = 'bar'
        } else if (entity.action.type === 'toToilet') {
            location = 'toilet'
        } else if (entity.action.type === 'toSmoke') {
            location = 'smoke'
        }
        if (location) {
            var movementData = {
                id: entity._id,
                name: entity.name,
                location: location,
                prediction: {}
            }
            // console.log('updateMovementData', movementList, movementData)
            var inList = false
            movementList.forEach(function (existingMovementData) {
                if (existingMovementData.id == movementData.id) {
                    inList = true
                    return null
                }
            })
            if (!inList) {
                movementList.push(movementData)
                renderMovementList()
            }
            var positionList = entity.action.positionList
            if (entity.prediction.position == null && positionList.length >= 5) {
                positionPredictionRequest(entity, positionList)
            }
            if (entity.prediction.drink == null) {
                drinkPredictionRequest(entity)
            }
        }
    }

    function publishPredictionResults(prediction, result) {
        console.log('publishPredictionResults', prediction, result)
        if (prediction.position === result.location) {
            predictionResults.position.correct++
        } else {
            predictionResults.position.wrong++
        }
        if (prediction.position === 'bar' || result.location === 'bar') {
            if (prediction.drink === result.drink) {
                predictionResults.drink.correct++
            } else {
                predictionResults.drink.wrong++
            }
        }
        renderPredictionResults()
    }

    function sendInfoToBartender(id, name, status, order, prediction) {
        // Predictions for movement and drink
        // Person arrived
        var data = {
            id: id,
            name: name,
            status: status,
            order: order,
            prediction: prediction
        }
        socket.emit('toBartender', data)
    }

    function handleBartenderCommunication(data) {
        console.log('fromBartender', data)
        // Bartender serving customer
        if (data.status === 'serving') {

            var orders = barQueue.filter(el => el.id === data.id)
            console.log('flagging serving', data, barQueue, orders)
            if (orders.length > 0) {
                orders[0].status = 'serving'
                renderBarQueue()
            }
        }

        // Customer has been served
        if (data.status === 'served') {
            var entity = entities[data.id]
            triggerServed(entity)
        }
    }

    function handleBartenderConnected(data) {
        console.log('handleBartenderConnected', data)
        connectedBartenders = data
        renderConnectedBartenders()
    }
    socket.on('bartenderConnected', handleBartenderConnected)
    socket.on('fromBartender', handleBartenderCommunication)

    function animate() {
        frameNo++
        var capturePositionData = false
        if (frameNo >= 60) {
            frameNo = 0
            capturePositionData = true
        }
        requestAnimationFrame(animate);


        var delta = clock.getDelta();
        THREE.SEA3D.AnimationHandler.update(delta);
        controls.update();


        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i]
            entity.maxSpeed = params.maxSpeed;
            entity.maxForce = params.maxForce;

            entity.setAnimation()

            if (entity.action.path && entity.action.path.length > 0) {
                entity.followPathAndReturn(entity.action.path, params.loop, params.thresholdRadius, function () {
                    var journeyData = broadcastPositionData(entity)
                    publishPredictionResults(entity.prediction, journeyData)
                    delete entity.prediction.position
                    delete entity.prediction.drink

                    movementList = movementList.filter(function (el) {
                        return el.id !== entity._id
                    })
                    renderMovementList()
                });
                entity.lookWhereGoing(true)
                if (params.avoid) {
                    entity.avoidDistance = params.avoidDistance;
                    entity.avoid(entities)
                    entity.avoid(furniture)
                }
                if (capturePositionData) {
                    entity.action.positionList.push([Math.floor(entity.position.x), Math.floor(entity.position.z)])
                    updateMovementDataAndPredict(entity)
                    // console.log('Entity:', entity.name, 'entity.action.positionList:', entity.action.positionList)
                }
            } else {
                entity.idle()
            }

            entity.update();

        }

        renderer.render(scene, camera);
        stats.update();

    }
    Entity.prototype.setAnimation = function () {
        if (this.velocity.length() <= 1)
            this.mesh.play(1, 0.5); //Idle

        else if (this.velocity.length() > 1 && this.velocity.length() <= 8)
            this.mesh.play(2, 0.5) //Walk

        else if (this.velocity.length() > 8 && this.velocity.length() <= 12)
            this.mesh.play(3, 0.5) //Jog

        else if (this.velocity.length() > 12)
            this.mesh.play(4, 0.5) //Run
    }
    SteeringEntity.prototype.followPathAndReturn = function (path, loop, thresholdRadius = 1, arrivalCallBack) {
        var wayPoint = path[this.pathIndex]
        if (wayPoint == null)
            return;
        if (this.position.distanceTo(wayPoint) < thresholdRadius) {
            if (this.pathIndex >= path.length - 1) {
                console.log('Entity:', this.name, 'Arrived:', this.action.type)
                this.action.path = []
                if (this.action.type === 'toBar') {
                    this.action.type === 'atBar'
                    //Send drink to bartender and wait, return will be in bartender loop
                    var id = this._id
                    barQueue.push({
                        id: id,
                        name: this.name,
                        drink: this.action.drink,
                        status: 'waiting',
                        prediction: this.prediction.drink
                    })
                    renderBarQueue()
                    sendInfoToBartender(id, this.name, 'waiting', this.action.drink, this.prediction.drink)
                    arrivalCallBack()
                } else if (this.action.type === 'toToilet') {
                    this.action.type === 'atToilet'
                    var idleTime = 20
                    var entity = this
                    setTimeout(function () {
                        entity.pathIndex = 0
                        entity.action.type = 'fromToilet'
                        entity.action.path = getPath(entity, entity.action.type)
                        console.log('Entity:', entity.name, 'Return:', entity.action.type)
                    }, idleTime);
                    if (this.prediction.position === 'bar') {
                        sendInfoToBartender(entity._id, entity.name, 'incorrect', entity.action.drink, entity.prediction
                            .drink)
                    }
                    arrivalCallBack()
                } else if (this.action.type === 'toSmoke') {
                    this.action.type === 'atSmoke'
                    var idleTime = 30
                    var entity = this
                    setTimeout(function () {
                        entity.pathIndex = 0
                        entity.action.type = 'fromSmoke'
                        entity.action.path = getPath(entity, entity.action.type)
                        console.log('Entity:', entity.name, 'Return:', entity.action.type)
                    }, idleTime);
                    if (this.prediction.position === 'bar') {
                        sendInfoToBartender(entity._id, entity.name, 'incorrect', entity.action.drink, entity.prediction
                            .drink)
                    }
                    arrivalCallBack()
                } else if (this.action.type === 'fromBar' || this.action.type === 'fromToilet' || this.action.type ===
                    'fromSmoke') {
                    entityActionInit(this, false)
                }


            } else {
                this.pathIndex++
            }
        }
        if (this.pathIndex >= path.length - 1 && !loop)
            this.arrive(wayPoint)
        else
            this.seek(wayPoint)
    }
</script>

<body onload="loadModels()">
    <div id="container"></div>
    <div id="barQueue">
        <h3>Bar Queue</h3>
        <div id="barQueueItems"></div>
    </div>
    <div id="movementQueue">
        <h3>Movement Queue</h3>
        <div id="movementQueueItems"></div>
    </div>
    <div id="predictionResults">
        <h3>Prediction Results</h3>
        <div id="predictionResultsItems">
            <p>Movements: 0 of 0</p>
            <p>Drinks: 0 of 0</p>
        </div>
    </div>
    <div id="connectedBartenders">
        <h3>Connected Bartenders</h3>
        <div id="connectedBartendersItems">
            <p>None - Auto-serve within 3 seconds</p>
        </div>
    </div>
    <div id="loading-msg"></div>
</body>

</html>